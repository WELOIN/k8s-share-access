#!/usr/bin/env bash
set -euo pipefail

### METADATA ###
SCRIPT_NAME="k8s-share-access"
INSTALL_PATH="/usr/local/bin/${SCRIPT_NAME}"

### NAMESPACE & ROLES ###
SHARED_NS="shared-access"
ROLE_RO="shared-readonly"
ROLE_RW="shared-readwrite"

### COLORS ###
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

### CURSOR CONTROL ###
hide_cursor() { tput civis 2>/dev/null || printf '\033[?25l'; }
show_cursor() { tput cnorm 2>/dev/null || printf '\033[?25h'; }
cursor_up() { tput cuu "$1" 2>/dev/null || printf '\033[%dA' "$1"; }
clear_line() { tput el 2>/dev/null || printf '\033[K'; }

# Ensure cursor is shown on exit
trap 'show_cursor' EXIT

### SINGLE SELECT FUNCTION ###
select_one() {
  local prompt="$1"
  shift
  local options=("$@")
  local selected=0
  local count=${#options[@]}
  local i key escape

  hide_cursor

  printf "\n${CYAN}${BOLD}%s${RESET}\n" "$prompt"
  printf "${DIM}Use â†‘/â†“ to navigate, Enter to select${RESET}\n\n"

  for i in "${!options[@]}"; do
    if [[ $i -eq $selected ]]; then
      printf "  ${GREEN}â¯ %s${RESET}\n" "${options[$i]}"
    else
      printf "    ${DIM}%s${RESET}\n" "${options[$i]}"
    fi
  done

  while true; do
    IFS= read -rsn1 key

    if [[ $key == $'\x1b' ]]; then
      IFS= read -rsn1 -t 1 escape
      if [[ $escape == "[" ]]; then
        IFS= read -rsn1 -t 1 escape
        case "$escape" in
          A) ((selected > 0)) && ((selected--)) ;;
          B) ((selected < count - 1)) && ((selected++)) ;;
        esac
      fi
    elif [[ $key == "" ]]; then
      break
    fi

    cursor_up "$count"
    for i in "${!options[@]}"; do
      printf "\r"
      clear_line
      if [[ $i -eq $selected ]]; then
        printf "  ${GREEN}â¯ %s${RESET}\n" "${options[$i]}"
      else
        printf "    ${DIM}%s${RESET}\n" "${options[$i]}"
      fi
    done
  done

  show_cursor
  SELECTED_INDEX=$selected
  SELECTED_VALUE="${options[$selected]}"
}

### MULTI SELECT FUNCTION ###
select_many() {
  local prompt="$1"
  shift
  local options=("$@")
  local count=${#options[@]}
  local selected=0
  local i key escape
  local -a checked=()

  for ((i = 0; i < count; i++)); do
    checked+=("false")
  done

  hide_cursor

  printf "\n${CYAN}${BOLD}%s${RESET}\n" "$prompt"
  printf "${DIM}Use â†‘/â†“ to navigate, Space to toggle, Enter to confirm${RESET}\n\n"

  for i in "${!options[@]}"; do
    if [[ $i -eq $selected ]]; then
      printf "  ${GREEN}â¯${RESET} [ ] %s\n" "${options[$i]}"
    else
      printf "    [ ] ${DIM}%s${RESET}\n" "${options[$i]}"
    fi
  done

  while true; do
    IFS= read -rsn1 key

    if [[ $key == $'\x1b' ]]; then
      IFS= read -rsn1 -t 1 escape
      if [[ $escape == "[" ]]; then
        IFS= read -rsn1 -t 1 escape
        case "$escape" in
          A) ((selected > 0)) && ((selected--)) ;;
          B) ((selected < count - 1)) && ((selected++)) ;;
        esac
      fi
    elif [[ $key == " " ]]; then
      if [[ "${checked[$selected]}" == "true" ]]; then
        checked[$selected]="false"
      else
        checked[$selected]="true"
      fi
    elif [[ $key == "" ]]; then
      break
    fi

    cursor_up "$count"
    for i in "${!options[@]}"; do
      printf "\r"
      clear_line
      if [[ "${checked[$i]}" == "true" ]]; then
        if [[ $i -eq $selected ]]; then
          printf "  ${GREEN}â¯${RESET} [${GREEN}âœ“${RESET}] %s\n" "${options[$i]}"
        else
          printf "    [${GREEN}âœ“${RESET}] ${DIM}%s${RESET}\n" "${options[$i]}"
        fi
      else
        if [[ $i -eq $selected ]]; then
          printf "  ${GREEN}â¯${RESET} [ ] %s\n" "${options[$i]}"
        else
          printf "    [ ] ${DIM}%s${RESET}\n" "${options[$i]}"
        fi
      fi
    done
  done

  show_cursor

  SELECTED_VALUES=()
  for i in "${!options[@]}"; do
    if [[ "${checked[$i]}" == "true" ]]; then
      SELECTED_VALUES+=("${options[$i]}")
    fi
  done
}

### MULTI SELECT WITH PRESELECTION ###
select_many_preselected() {
  local prompt="$1"
  shift
  local -a preselected=()

  # Parse preselected items (format: --preselected item1 item2 ... --)
  if [[ "$1" == "--preselected" ]]; then
    shift
    while [[ $# -gt 0 && "$1" != "--" ]]; do
      preselected+=("$1")
      shift
    done
    [[ "$1" == "--" ]] && shift
  fi

  local options=("$@")
  local count=${#options[@]}
  local selected=0
  local i key escape
  local -a checked=()

  # Initialize checked array with preselected items
  for ((i = 0; i < count; i++)); do
    local is_preselected=false
    for pre in "${preselected[@]+"${preselected[@]}"}"; do
      if [[ "${options[$i]}" == "$pre" ]]; then
        is_preselected=true
        break
      fi
    done
    if [[ "$is_preselected" == "true" ]]; then
      checked+=("true")
    else
      checked+=("false")
    fi
  done

  hide_cursor

  printf "\n${CYAN}${BOLD}%s${RESET}\n" "$prompt"
  printf "${DIM}Use â†‘/â†“ to navigate, Space to toggle, Enter to confirm${RESET}\n\n"

  for i in "${!options[@]}"; do
    if [[ "${checked[$i]}" == "true" ]]; then
      if [[ $i -eq $selected ]]; then
        printf "  ${GREEN}â¯${RESET} [${GREEN}âœ“${RESET}] %s\n" "${options[$i]}"
      else
        printf "    [${GREEN}âœ“${RESET}] ${DIM}%s${RESET}\n" "${options[$i]}"
      fi
    else
      if [[ $i -eq $selected ]]; then
        printf "  ${GREEN}â¯${RESET} [ ] %s\n" "${options[$i]}"
      else
        printf "    [ ] ${DIM}%s${RESET}\n" "${options[$i]}"
      fi
    fi
  done

  while true; do
    IFS= read -rsn1 key

    if [[ $key == $'\x1b' ]]; then
      IFS= read -rsn1 -t 1 escape
      if [[ $escape == "[" ]]; then
        IFS= read -rsn1 -t 1 escape
        case "$escape" in
          A) ((selected > 0)) && ((selected--)) ;;
          B) ((selected < count - 1)) && ((selected++)) ;;
        esac
      fi
    elif [[ $key == " " ]]; then
      if [[ "${checked[$selected]}" == "true" ]]; then
        checked[$selected]="false"
      else
        checked[$selected]="true"
      fi
    elif [[ $key == "" ]]; then
      break
    fi

    cursor_up "$count"
    for i in "${!options[@]}"; do
      printf "\r"
      clear_line
      if [[ "${checked[$i]}" == "true" ]]; then
        if [[ $i -eq $selected ]]; then
          printf "  ${GREEN}â¯${RESET} [${GREEN}âœ“${RESET}] %s\n" "${options[$i]}"
        else
          printf "    [${GREEN}âœ“${RESET}] ${DIM}%s${RESET}\n" "${options[$i]}"
        fi
      else
        if [[ $i -eq $selected ]]; then
          printf "  ${GREEN}â¯${RESET} [ ] %s\n" "${options[$i]}"
        else
          printf "    [ ] ${DIM}%s${RESET}\n" "${options[$i]}"
        fi
      fi
    done
  done

  show_cursor

  SELECTED_VALUES=()
  for i in "${!options[@]}"; do
    if [[ "${checked[$i]}" == "true" ]]; then
      SELECTED_VALUES+=("${options[$i]}")
    fi
  done
}

usage() {
  cat <<EOF
${BOLD}${CYAN}$SCRIPT_NAME${RESET} - Kubernetes Access Sharing Tool

${BOLD}Usage:${RESET}
  $SCRIPT_NAME              Interactive mode
  $SCRIPT_NAME --install    Install globally (macOS/Linux)
  $SCRIPT_NAME --help       Show this help message

EOF
  exit 0
}

### --help ###
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  usage
fi

### --install ###
if [[ "${1:-}" == "--install" ]]; then
  printf "${CYAN}ğŸ“¦ Installing $SCRIPT_NAME globally...${RESET}\n"

  if [[ "$EUID" -ne 0 ]]; then
    printf "${YELLOW}ğŸ” sudo required for installation${RESET}\n"
    sudo cp "$0" "$INSTALL_PATH"
    sudo chmod +x "$INSTALL_PATH"
  else
    cp "$0" "$INSTALL_PATH"
    chmod +x "$INSTALL_PATH"
  fi

  printf "${GREEN}âœ… Installed to $INSTALL_PATH${RESET}\n"
  printf "ğŸ‘‰ You can now run: ${BOLD}$SCRIPT_NAME${RESET}\n"
  exit 0
fi

choose_context() {
  local contexts=()
  while IFS= read -r line; do
    contexts+=("$line")
  done < <(kubectl config get-contexts -o name 2>/dev/null)

  if [[ ${#contexts[@]} -eq 0 ]]; then
    printf "${RED}âŒ No Kubernetes contexts found${RESET}\n"
    exit 1
  fi

  select_one "Select Kubernetes context:" "${contexts[@]}"
  CONTEXT="$SELECTED_VALUE"
  printf "\n${GREEN}âœ“${RESET} Selected context: ${BOLD}%s${RESET}\n" "$CONTEXT"
}

ensure_namespace() {
  kubectl --context="$CONTEXT" get ns "$SHARED_NS" &>/dev/null || \
    kubectl --context="$CONTEXT" create ns "$SHARED_NS" >/dev/null
}

### LIST USERS ###
list_users() {
  printf "\n${CYAN}${BOLD}ğŸ“‹ Shared users in context: %s${RESET}\n" "$CONTEXT"
  printf "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
  printf "â”‚ ${BOLD}%-22s${RESET} â”‚ ${BOLD}%-22s${RESET} â”‚ ${BOLD}%-20s${RESET} â”‚\n" "User" "Namespace" "Access"
  printf "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"

  local bindings
  bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=NS:.metadata.namespace,SA:.subjects[0].name,ROLE:.roleRef.name \
    --no-headers 2>/dev/null | grep -E "(${ROLE_RO}|${ROLE_RW})" || true)

  if [[ -n "$bindings" ]]; then
    while IFS= read -r line; do
      local ns sa role access
      ns=$(echo "$line" | awk '{print $1}')
      sa=$(echo "$line" | awk '{print $2}')
      role=$(echo "$line" | awk '{print $3}')
      if [[ "$role" == "$ROLE_RO" ]]; then
        access="Read-only"
      else
        access="Read-write"
      fi
      printf "â”‚ %-22s â”‚ %-22s â”‚ %-20s â”‚\n" "$sa" "$ns" "$access"
    done <<< "$bindings"
  else
    printf "â”‚ ${DIM}%-22s${RESET} â”‚ ${DIM}%-22s${RESET} â”‚ ${DIM}%-20s${RESET} â”‚\n" "(no users found)" "-" "-"
  fi

  printf "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"

  printf "\n"
  read -rp "Press Enter to continue..."
}

### DELETE USER ###
delete_user() {
  # Get list of users
  local users=()
  local bindings
  bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=SA:.subjects[0].name \
    --no-headers 2>/dev/null | grep -v "<none>" | sort -u || true)

  if [[ -z "$bindings" ]]; then
    printf "\n${YELLOW}No users found to delete.${RESET}\n"
    printf "\n"
    read -rp "Press Enter to continue..."
    return
  fi

  while IFS= read -r line; do
    users+=("$line")
  done <<< "$bindings"

  users+=("â† Go back")
  select_one "Select user to delete:" "${users[@]}"

  if [[ "$SELECTED_VALUE" == "â† Go back" ]]; then
    return
  fi

  local user_to_delete="$SELECTED_VALUE"

  # Show user details
  printf "\n${YELLOW}${BOLD}âš ï¸  User '%s' will be deleted${RESET}\n\n" "$user_to_delete"
  printf "${BOLD}Current Access:${RESET}\n"

  local user_bindings
  user_bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=NS:.metadata.namespace,ROLE:.roleRef.name \
    --no-headers 2>/dev/null | grep -E "(${ROLE_RO}|${ROLE_RW})" || true)

  # Get namespaces for this user
  local ns_bindings
  ns_bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=NS:.metadata.namespace,SA:.subjects[0].name,ROLE:.roleRef.name \
    --no-headers 2>/dev/null | grep "[[:space:]]${user_to_delete}[[:space:]]" || true)

  if [[ -n "$ns_bindings" ]]; then
    while IFS= read -r line; do
      local ns role
      ns=$(echo "$line" | awk '{print $1}')
      role=$(echo "$line" | awk '{print $3}')
      printf "  - %s (%s)\n" "$ns" "$role"
    done <<< "$ns_bindings"
  fi

  select_one "Are you sure you want to delete this user?" "Yes, delete" "No, cancel"

  if [[ "$SELECTED_INDEX" -eq 1 ]]; then
    printf "\n${YELLOW}Cancelled.${RESET}\n"
    return
  fi

  printf "\n${CYAN}ğŸ—‘ï¸  Deleting user: %s${RESET}\n" "$user_to_delete"

  # Delete RoleBindings
  local namespaces_with_bindings
  namespaces_with_bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=NS:.metadata.namespace,NAME:.metadata.name,SA:.subjects[0].name \
    --no-headers 2>/dev/null | grep "[[:space:]]${user_to_delete}$" || true)

  if [[ -n "$namespaces_with_bindings" ]]; then
    while IFS= read -r line; do
      local ns binding_name
      ns=$(echo "$line" | awk '{print $1}')
      binding_name=$(echo "$line" | awk '{print $2}')
      printf "  ${DIM}Removing binding from %s...${RESET}" "$ns"
      kubectl --context="$CONTEXT" delete rolebinding "$binding_name" -n "$ns" --ignore-not-found >/dev/null 2>&1
      printf "\r  ${GREEN}âœ“${RESET} Removed binding from %s\n" "$ns"
    done <<< "$namespaces_with_bindings"
  fi

  # Delete ClusterRoleBinding if exists
  if kubectl --context="$CONTEXT" get clusterrolebinding "${user_to_delete}-cluster-access" &>/dev/null; then
    printf "  ${DIM}Removing cluster access...${RESET}"
    kubectl --context="$CONTEXT" delete clusterrolebinding "${user_to_delete}-cluster-access" --ignore-not-found >/dev/null 2>&1
    printf "\r  ${GREEN}âœ“${RESET} Removed cluster access\n"
  fi

  # Delete ClusterRole if exists
  if kubectl --context="$CONTEXT" get clusterrole "${user_to_delete}-cluster-access" &>/dev/null; then
    kubectl --context="$CONTEXT" delete clusterrole "${user_to_delete}-cluster-access" --ignore-not-found >/dev/null 2>&1
  fi

  # Delete ServiceAccount
  printf "  ${DIM}Removing ServiceAccount...${RESET}"
  kubectl --context="$CONTEXT" delete serviceaccount "$user_to_delete" -n "$SHARED_NS" --ignore-not-found >/dev/null 2>&1
  printf "\r  ${GREEN}âœ“${RESET} Removed ServiceAccount\n"

  printf "\n${GREEN}${BOLD}âœ… User '%s' deleted successfully!${RESET}\n" "$user_to_delete"
  printf "\n"
  read -rp "Press Enter to continue..."
}

### EDIT USER ###
edit_user() {
  # Get list of users from rolebindings
  local users=()
  local bindings
  bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=SA:.subjects[0].name \
    --no-headers 2>/dev/null | grep -v "<none>" | sort -u || true)

  if [[ -z "$bindings" ]]; then
    printf "\n${YELLOW}No users found to edit.${RESET}\n"
    printf "\n"
    read -rp "Press Enter to continue..."
    return
  fi

  while IFS= read -r line; do
    users+=("$line")
  done <<< "$bindings"

  users+=("â† Go back")
  select_one "Select user to edit:" "${users[@]}"

  if [[ "$SELECTED_VALUE" == "â† Go back" ]]; then
    return
  fi

  local user_to_edit="$SELECTED_VALUE"

  # Get current access info for this user
  local current_bindings
  current_bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
    -o custom-columns=NS:.metadata.namespace,SA:.subjects[0].name,ROLE:.roleRef.name \
    --no-headers 2>/dev/null | grep "[[:space:]]${user_to_edit}[[:space:]]" || true)

  # Extract current namespaces and access level
  local current_namespaces=()
  local current_mode=""
  if [[ -n "$current_bindings" ]]; then
    while IFS= read -r line; do
      local ns role
      ns=$(echo "$line" | awk '{print $1}')
      role=$(echo "$line" | awk '{print $3}')
      current_namespaces+=("$ns")
      # Determine mode from first binding found
      if [[ -z "$current_mode" ]]; then
        if [[ "$role" == "$ROLE_RO" ]]; then
          current_mode="ro"
        else
          current_mode="rw"
        fi
      fi
    done <<< "$current_bindings"
  fi

  # Get current cluster-wide options from ClusterRole
  local current_cluster_options=()
  local cluster_role_yaml
  cluster_role_yaml=$(kubectl --context="$CONTEXT" get clusterrole "${user_to_edit}-cluster-access" -o yaml 2>/dev/null || true)
  if [[ -n "$cluster_role_yaml" ]]; then
    if echo "$cluster_role_yaml" | grep -q '"nodes"'; then
      current_cluster_options+=("View nodes")
    fi
    if echo "$cluster_role_yaml" | grep -q '"persistentvolumes"'; then
      current_cluster_options+=("View storage")
    fi
    if echo "$cluster_role_yaml" | grep -q '"events"' && echo "$cluster_role_yaml" | grep -q '"watch"'; then
      current_cluster_options+=("View cluster events")
    fi
  fi

  # Show current access
  printf "\n${CYAN}${BOLD}ğŸ“ Editing user: %s${RESET}\n\n" "$user_to_edit"
  printf "${BOLD}Current Access:${RESET}\n"
  printf "  Access level: ${BOLD}%s${RESET}\n" "$([[ "$current_mode" == "ro" ]] && echo "Read-only" || echo "Read-write")"
  printf "  Namespaces:   ${BOLD}%d${RESET} (" "${#current_namespaces[@]}"
  printf "%s" "${current_namespaces[*]}"
  printf ")\n"
  if [[ ${#current_cluster_options[@]} -gt 0 ]]; then
    printf "  Cluster:      ${BOLD}%s${RESET}\n" "${current_cluster_options[*]}"
  else
    printf "  Cluster:      ${DIM}None${RESET}\n"
  fi
  printf "\n${DIM}Note: Editing will not change the user's credentials (ServiceAccount/token remain unchanged)${RESET}\n"

  # Choose new access level
  local default_access_idx=0
  [[ "$current_mode" == "rw" ]] && default_access_idx=1

  if [[ "$default_access_idx" -eq 0 ]]; then
    select_one "Select access level:" "Read-only (view resources) [current]" "Read-write (full access)" "â† Go back"
  else
    select_one "Select access level:" "Read-only (view resources)" "Read-write (full access) [current]" "â† Go back"
  fi

  if [[ "$SELECTED_INDEX" -eq 2 ]]; then
    return
  elif [[ "$SELECTED_INDEX" -eq 0 ]]; then
    MODE="ro"
    printf "\n${GREEN}âœ“${RESET} Access level: ${BOLD}Read-only${RESET}\n"
  else
    MODE="rw"
    printf "\n${GREEN}âœ“${RESET} Access level: ${BOLD}Read-write${RESET}\n"
  fi

  # Choose namespaces (with current ones pre-selected)
  select_one "Grant access to all namespaces?" "Yes - all namespaces" "No - select specific namespaces" "â† Go back"

  if [[ "$SELECTED_INDEX" -eq 2 ]]; then
    return
  elif [[ "$SELECTED_INDEX" -eq 0 ]]; then
    NAMESPACES=()
    while IFS= read -r line; do
      NAMESPACES+=("$line")
    done < <(kubectl --context="$CONTEXT" get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')
    printf "\n${GREEN}âœ“${RESET} Granting access to ${BOLD}all %d namespaces${RESET}\n" "${#NAMESPACES[@]}"
  else
    ns_list=()
    while IFS= read -r line; do
      ns_list+=("$line")
    done < <(kubectl --context="$CONTEXT" get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')

    # Use preselected multi-select with current namespaces checked
    select_many_preselected "Select namespaces:" --preselected "${current_namespaces[@]+"${current_namespaces[@]}"}" -- "${ns_list[@]}"

    if [[ ${#SELECTED_VALUES[@]} -eq 0 ]]; then
      printf "\n${RED}âŒ At least one namespace must be selected${RESET}\n"
      return
    fi

    NAMESPACES=("${SELECTED_VALUES[@]}")
    printf "\n${GREEN}âœ“${RESET} Selected ${BOLD}%d namespaces${RESET}\n" "${#NAMESPACES[@]}"
  fi

  # Cluster access options (with current ones pre-selected)
  select_many_preselected "Select cluster-wide access (optional):" --preselected "${current_cluster_options[@]+"${current_cluster_options[@]}"}" -- "View nodes" "View storage" "View cluster events"

  CLUSTER_OPTIONS=("${SELECTED_VALUES[@]+"${SELECTED_VALUES[@]}"}")
  if [[ ${#CLUSTER_OPTIONS[@]} -gt 0 ]]; then
    printf "\n${GREEN}âœ“${RESET} Cluster access: ${BOLD}%s${RESET}\n" "${CLUSTER_OPTIONS[*]}"
  else
    printf "\n${GREEN}âœ“${RESET} Cluster access: ${DIM}None${RESET}\n"
  fi

  # Summary
  printf "\n${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"
  printf "${BOLD}Summary of Changes:${RESET}\n"
  printf "  User:           ${BOLD}%s${RESET}\n" "$user_to_edit"
  printf "  Access:         ${BOLD}%s${RESET}" "$([[ "$MODE" == "ro" ]] && echo "Read-only" || echo "Read-write")"
  [[ "$MODE" != "$current_mode" ]] && printf " ${YELLOW}(changed)${RESET}"
  printf "\n"
  printf "  Namespaces:     ${BOLD}%d${RESET}" "${#NAMESPACES[@]}"

  # Calculate namespace changes
  local added_ns=() removed_ns=()
  for ns in "${NAMESPACES[@]}"; do
    local found=false
    for cns in "${current_namespaces[@]+"${current_namespaces[@]}"}"; do
      [[ "$ns" == "$cns" ]] && found=true && break
    done
    [[ "$found" == "false" ]] && added_ns+=("$ns")
  done
  for cns in "${current_namespaces[@]+"${current_namespaces[@]}"}"; do
    local found=false
    for ns in "${NAMESPACES[@]}"; do
      [[ "$cns" == "$ns" ]] && found=true && break
    done
    [[ "$found" == "false" ]] && removed_ns+=("$cns")
  done

  if [[ ${#added_ns[@]} -gt 0 || ${#removed_ns[@]} -gt 0 ]]; then
    printf " ${YELLOW}(changed)${RESET}"
  fi
  printf "\n"

  if [[ ${#added_ns[@]} -gt 0 ]]; then
    printf "                  ${GREEN}+ Adding: %s${RESET}\n" "${added_ns[*]}"
  fi
  if [[ ${#removed_ns[@]} -gt 0 ]]; then
    printf "                  ${RED}- Removing: %s${RESET}\n" "${removed_ns[*]}"
  fi

  if [[ ${#CLUSTER_OPTIONS[@]} -gt 0 ]]; then
    printf "  Cluster access: ${BOLD}%s${RESET}\n" "${CLUSTER_OPTIONS[*]}"
  fi
  printf "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"

  select_one "Apply these changes?" "Yes, apply" "No, cancel"
  if [[ "$SELECTED_INDEX" -eq 1 ]]; then
    printf "\n${YELLOW}Cancelled.${RESET}\n"
    return
  fi

  # Apply changes
  printf "\n${CYAN}ğŸ”§ Updating access for: %s${RESET}\n" "$user_to_edit"

  ROLE_NAME=$([[ "$MODE" == "ro" ]] && echo "$ROLE_RO" || echo "$ROLE_RW")

  # Remove bindings for namespaces that are no longer granted
  if [[ ${#removed_ns[@]} -gt 0 ]]; then
    printf "${CYAN}ğŸ—‘ï¸  Removing access from namespaces...${RESET}\n"
    for ns in "${removed_ns[@]}"; do
      printf "  ${DIM}â¡ï¸  %s${RESET}" "$ns"
      kubectl --context="$CONTEXT" delete rolebinding "${user_to_edit}-binding" -n "$ns" --ignore-not-found >/dev/null 2>&1
      printf "\r  ${RED}âœ—${RESET}  %s (removed)\n" "$ns"
    done
  fi

  # Apply/update bindings for all selected namespaces
  printf "${CYAN}ğŸ“ Applying access to namespaces...${RESET}\n"
  for ns in "${NAMESPACES[@]}"; do
    printf "  ${DIM}â¡ï¸  %s${RESET}" "$ns"
    create_role "$ns" "$MODE"
    bind_role "$ns" "$user_to_edit" "$ROLE_NAME"
    printf "\r  ${GREEN}âœ“${RESET}  %s\n" "$ns"
  done

  # Update cluster role
  printf "${CYAN}ğŸŒ Updating cluster-wide access...${RESET}\n"
  create_cluster_role "$user_to_edit" ${CLUSTER_OPTIONS[@]+"${CLUSTER_OPTIONS[@]}"}
  bind_cluster_role "$user_to_edit"
  printf "  ${GREEN}âœ“${RESET} Namespace listing enabled\n"
  if [[ ${#CLUSTER_OPTIONS[@]} -gt 0 ]]; then
    printf "  ${GREEN}âœ“${RESET} Additional: ${CLUSTER_OPTIONS[*]}\n"
  fi

  printf "\n${GREEN}${BOLD}âœ… User '%s' updated successfully!${RESET}\n" "$user_to_edit"
  printf "${DIM}   Note: User's credentials remain unchanged. No need to regenerate kubeconfig.${RESET}\n"
  printf "\n"
  read -rp "Press Enter to continue..."
}

### CREATE ROLE ###
create_role() {
  local ns="$1"
  local mode="$2"

  if [[ "$mode" == "ro" ]]; then
    kubectl --context="$CONTEXT" apply -n "$ns" -f - <<EOF >/dev/null
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: $ROLE_RO
rules:
- apiGroups: [""]
  resources: [pods, pods/log, services, endpoints, configmaps, secrets, events, persistentvolumeclaims]
  verbs: [get, list, watch]
- apiGroups: ["apps"]
  resources: [deployments, replicasets, statefulsets, daemonsets]
  verbs: [get, list, watch]
- apiGroups: ["batch"]
  resources: [jobs, cronjobs]
  verbs: [get, list, watch]
- apiGroups: ["networking.k8s.io"]
  resources: [ingresses, networkpolicies]
  verbs: [get, list, watch]
- apiGroups: ["autoscaling"]
  resources: [horizontalpodautoscalers]
  verbs: [get, list, watch]
EOF
  else
    kubectl --context="$CONTEXT" apply -n "$ns" -f - <<EOF >/dev/null
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: $ROLE_RW
rules:
- apiGroups: [""]
  resources: [pods, pods/log, pods/exec, services, endpoints, configmaps, secrets, events, persistentvolumeclaims]
  verbs: [get, list, watch, create, update, patch, delete]
- apiGroups: ["apps"]
  resources: [deployments, replicasets, statefulsets, daemonsets]
  verbs: [get, list, watch, create, update, patch, delete]
- apiGroups: ["batch"]
  resources: [jobs, cronjobs]
  verbs: [get, list, watch, create, update, patch, delete]
- apiGroups: ["networking.k8s.io"]
  resources: [ingresses, networkpolicies]
  verbs: [get, list, watch, create, update, patch, delete]
- apiGroups: ["autoscaling"]
  resources: [horizontalpodautoscalers]
  verbs: [get, list, watch, create, update, patch, delete]
EOF
  fi
}

bind_role() {
  local ns="$1"
  local sa="$2"
  local role="$3"

  kubectl --context="$CONTEXT" apply -n "$ns" -f - <<EOF >/dev/null
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ${sa}-binding
subjects:
- kind: ServiceAccount
  name: $sa
  namespace: $SHARED_NS
roleRef:
  kind: Role
  name: $role
  apiGroup: rbac.authorization.k8s.io
EOF
}

create_cluster_role() {
  local sa="$1"
  shift
  local options=()
  [[ $# -gt 0 ]] && options=("$@")

  # Always include namespace listing permission
  local rules='
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list"]'

  if [[ ${#options[@]} -gt 0 ]]; then
    for opt in "${options[@]}"; do
      case "$opt" in
      "View nodes")
        rules+='
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list"]'
        ;;
      "View storage")
        rules+='
- apiGroups: [""]
  resources: ["persistentvolumes"]
  verbs: ["get", "list"]
- apiGroups: ["storage.k8s.io"]
  resources: ["storageclasses"]
  verbs: ["get", "list"]'
        ;;
      "View cluster events")
        rules+='
- apiGroups: [""]
  resources: ["events"]
  verbs: ["get", "list", "watch"]'
        ;;
      esac
    done
  fi

  kubectl --context="$CONTEXT" apply -f - <<EOF >/dev/null
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: ${sa}-cluster-access
rules:${rules}
EOF
}

bind_cluster_role() {
  local sa="$1"

  kubectl --context="$CONTEXT" apply -f - <<EOF >/dev/null
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: ${sa}-cluster-access
subjects:
- kind: ServiceAccount
  name: $sa
  namespace: $SHARED_NS
roleRef:
  kind: ClusterRole
  name: ${sa}-cluster-access
  apiGroup: rbac.authorization.k8s.io
EOF
}

generate_secret_token() {
  local sa="$1"
  local secret_name="${sa}-token"

  # Create secret bound to service account
  kubectl --context="$CONTEXT" apply -n "$SHARED_NS" -f - <<EOF >/dev/null
apiVersion: v1
kind: Secret
metadata:
  name: $secret_name
  annotations:
    kubernetes.io/service-account.name: $sa
type: kubernetes.io/service-account-token
EOF

  # Wait for token to be populated (up to 10 seconds)
  local token=""
  for i in {1..10}; do
    token=$(kubectl --context="$CONTEXT" get secret "$secret_name" -n "$SHARED_NS" \
      -o jsonpath='{.data.token}' 2>/dev/null | base64 -d)
    [[ -n "$token" ]] && break
    sleep 1
  done

  if [[ -z "$token" ]]; then
    printf "${RED}âŒ Failed to generate token${RESET}\n"
    return 1
  fi

  echo "$token"
}

generate_kubeconfig() {
  local sa="$1"
  local duration="$2"
  local expiry_label="$3"
  local use_secret="$4"
  shift 4
  local namespaces=("$@")

  if [[ "$use_secret" == "true" ]]; then
    printf "${CYAN}ğŸ” Generating long-lived token (never expires)...${RESET}\n"
    TOKEN=$(generate_secret_token "$sa")
    [[ -z "$TOKEN" ]] && return 1
  else
    printf "${CYAN}ğŸ” Generating token (expires in %s)...${RESET}\n" "$expiry_label"
    TOKEN=$(kubectl --context="$CONTEXT" create token "$sa" -n "$SHARED_NS" --duration="$duration")
  fi

  CLUSTER=$(kubectl config view --raw -o jsonpath="{.contexts[?(@.name==\"$CONTEXT\")].context.cluster}")
  SERVER=$(kubectl config view --raw -o jsonpath="{.clusters[?(@.name==\"$CLUSTER\")].cluster.server}")
  CA=$(kubectl config view --raw -o jsonpath="{.clusters[?(@.name==\"$CLUSTER\")].cluster.certificate-authority-data}")

  FILE="kubeconfig-${sa}.yaml"

  # Build namespace list for comments
  local ns_list=""
  for ns in "${namespaces[@]}"; do
    ns_list+="#   - ${ns}\n"
  done

  cat <<EOF > "$FILE"
apiVersion: v1
kind: Config
#
# Token expires in: $expiry_label
#
# Accessible namespaces:
$(printf "#   - %s\n" "${namespaces[@]}")
#
# Usage:
#   kubectl get pods -n <namespace>
#   kubectl config set-context --current --namespace=<namespace>
#
clusters:
- name: $CLUSTER
  cluster:
    server: $SERVER
    certificate-authority-data: $CA
users:
- name: $sa
  user:
    token: $TOKEN
contexts:
- name: ${sa}@${CLUSTER}
  context:
    cluster: ${CLUSTER}
    user: ${sa}
current-context: ${sa}@${CLUSTER}
EOF

  printf "${GREEN}ğŸ“„ kubeconfig written: ${BOLD}$FILE${RESET}\n"
  printf "${DIM}   Access to %d namespaces${RESET}\n" "${#namespaces[@]}"
}

### CREATE USER ###
create_user() {
  # Enter username
  printf "\n${CYAN}${BOLD}Enter username (ServiceAccount name):${RESET}\n"
  printf "${DIM}This will be used to create/update the ServiceAccount${RESET}\n"
  printf "  ${GREEN}â¯${RESET} "
  read -r USER
  [[ -z "$USER" ]] && { printf "${RED}âŒ Username required${RESET}\n"; return; }

  # Check if user exists
  if kubectl --context="$CONTEXT" get serviceaccount "$USER" -n "$SHARED_NS" &>/dev/null; then
    printf "\n${YELLOW}${BOLD}âš ï¸  User '%s' already exists!${RESET}\n\n" "$USER"

    printf "${BOLD}Current Access:${RESET}\n"
    local bindings
    bindings=$(kubectl --context="$CONTEXT" get rolebindings -A \
      -o custom-columns=NS:.metadata.namespace,SA:.subjects[0].name,ROLE:.roleRef.name \
      --no-headers 2>/dev/null | grep "^.*[[:space:]]${USER}[[:space:]]" || true)

    if [[ -n "$bindings" ]]; then
      while IFS= read -r line; do
        local ns role
        ns=$(echo "$line" | awk '{print $1}')
        role=$(echo "$line" | awk '{print $3}')
        printf "  - %s (%s)\n" "$ns" "$role"
      done <<< "$bindings"
    else
      printf "  ${DIM}(no bindings found)${RESET}\n"
    fi

    select_one "Do you want to overwrite this user?" "Yes, overwrite" "No, cancel"

    if [[ "$SELECTED_INDEX" -eq 1 ]]; then
      printf "\n${YELLOW}Cancelled.${RESET}\n"
      return
    fi
    printf "\n${CYAN}Proceeding with overwrite...${RESET}\n"
  fi

  # Choose access level
  select_one "Select access level:" "Read-only (view resources)" "Read-write (full access)" "â† Go back"
  if [[ "$SELECTED_INDEX" -eq 2 ]]; then
    return
  elif [[ "$SELECTED_INDEX" -eq 0 ]]; then
    MODE="ro"
    printf "\n${GREEN}âœ“${RESET} Access level: ${BOLD}Read-only${RESET}\n"
  else
    MODE="rw"
    printf "\n${GREEN}âœ“${RESET} Access level: ${BOLD}Read-write${RESET}\n"
  fi

  # Choose namespaces
  select_one "Grant access to all namespaces?" "Yes - all namespaces" "No - select specific namespaces" "â† Go back"

  if [[ "$SELECTED_INDEX" -eq 2 ]]; then
    return
  elif [[ "$SELECTED_INDEX" -eq 0 ]]; then
    NAMESPACES=()
    while IFS= read -r line; do
      NAMESPACES+=("$line")
    done < <(kubectl --context="$CONTEXT" get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')
    printf "\n${GREEN}âœ“${RESET} Granting access to ${BOLD}all %d namespaces${RESET}\n" "${#NAMESPACES[@]}"
  else
    ns_list=()
    while IFS= read -r line; do
      ns_list+=("$line")
    done < <(kubectl --context="$CONTEXT" get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')
    select_many "Select namespaces:" "${ns_list[@]}"

    if [[ ${#SELECTED_VALUES[@]} -eq 0 ]]; then
      printf "\n${RED}âŒ At least one namespace must be selected${RESET}\n"
      return
    fi

    NAMESPACES=("${SELECTED_VALUES[@]}")
    printf "\n${GREEN}âœ“${RESET} Selected ${BOLD}%d namespaces${RESET}\n" "${#NAMESPACES[@]}"
  fi

  # Cluster access options
  select_many "Select cluster-wide access (optional):" "View nodes" "View storage" "View cluster events"

  CLUSTER_OPTIONS=("${SELECTED_VALUES[@]+"${SELECTED_VALUES[@]}"}")
  if [[ ${#CLUSTER_OPTIONS[@]} -gt 0 ]]; then
    printf "\n${GREEN}âœ“${RESET} Cluster access: ${BOLD}%s${RESET}\n" "${CLUSTER_OPTIONS[*]}"
  else
    printf "\n${GREEN}âœ“${RESET} Cluster access: ${DIM}None${RESET}\n"
  fi

  # Token expiry
  select_one "Select token expiry:" "24 hours" "1 week" "1 month" "1 year" "Never expires (long-lived)" "â† Go back"
  USE_SECRET_TOKEN=false
  case "$SELECTED_INDEX" in
    0) TOKEN_DURATION="24h"; TOKEN_EXPIRY_LABEL="24 hours" ;;
    1) TOKEN_DURATION="168h"; TOKEN_EXPIRY_LABEL="1 week" ;;
    2) TOKEN_DURATION="720h"; TOKEN_EXPIRY_LABEL="1 month" ;;
    3) TOKEN_DURATION="8760h"; TOKEN_EXPIRY_LABEL="1 year" ;;
    4) TOKEN_DURATION=""; TOKEN_EXPIRY_LABEL="Never expires"; USE_SECRET_TOKEN=true ;;
    5) return ;;
  esac
  printf "\n${GREEN}âœ“${RESET} Token expiry: ${BOLD}%s${RESET}\n" "$TOKEN_EXPIRY_LABEL"

  # Summary
  printf "\n${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"
  printf "${BOLD}Summary:${RESET}\n"
  printf "  User:           ${BOLD}%s${RESET}\n" "$USER"
  printf "  Access:         ${BOLD}%s${RESET}\n" "$([[ "$MODE" == "ro" ]] && echo "Read-only" || echo "Read-write")"
  printf "  Namespaces:     ${BOLD}%d${RESET}\n" "${#NAMESPACES[@]}"
  if [[ ${#CLUSTER_OPTIONS[@]} -gt 0 ]]; then
    printf "  Cluster access: ${BOLD}%s${RESET}\n" "${CLUSTER_OPTIONS[*]}"
  fi
  printf "  Token expiry:   ${BOLD}%s${RESET}\n" "$TOKEN_EXPIRY_LABEL"
  printf "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"

  select_one "Proceed with this configuration?" "Yes, apply" "No, cancel"
  if [[ "$SELECTED_INDEX" -eq 1 ]]; then
    printf "\n${YELLOW}Cancelled.${RESET}\n"
    return
  fi

  # Apply configuration
  ensure_namespace
  printf "\n${CYAN}ğŸ”§ Creating ServiceAccount: %s${RESET}\n" "$USER"
  kubectl --context="$CONTEXT" apply -n "$SHARED_NS" -f - <<EOF >/dev/null
apiVersion: v1
kind: ServiceAccount
metadata:
  name: $USER
EOF

  ROLE_NAME=$([[ "$MODE" == "ro" ]] && echo "$ROLE_RO" || echo "$ROLE_RW")

  printf "${CYAN}ğŸ“ Applying access to namespaces...${RESET}\n"
  for ns in "${NAMESPACES[@]}"; do
    printf "  ${DIM}â¡ï¸  %s${RESET}" "$ns"
    create_role "$ns" "$MODE"
    bind_role "$ns" "$USER" "$ROLE_NAME"
    printf "\r  ${GREEN}âœ“${RESET}  %s\n" "$ns"
  done

  printf "${CYAN}ğŸŒ Applying cluster-wide access...${RESET}\n"
  create_cluster_role "$USER" ${CLUSTER_OPTIONS[@]+"${CLUSTER_OPTIONS[@]}"}
  bind_cluster_role "$USER"
  printf "  ${GREEN}âœ“${RESET} Namespace listing enabled\n"
  if [[ ${#CLUSTER_OPTIONS[@]} -gt 0 ]]; then
    printf "  ${GREEN}âœ“${RESET} Additional: ${CLUSTER_OPTIONS[*]}\n"
  fi

  generate_kubeconfig "$USER" "$TOKEN_DURATION" "$TOKEN_EXPIRY_LABEL" "$USE_SECRET_TOKEN" "${NAMESPACES[@]}"

  printf "\n${GREEN}${BOLD}ğŸ‰ Access successfully granted!${RESET}\n"
  printf "ğŸ‘‰ Share the generated kubeconfig file securely.\n"
  printf "${DIM}   User can run: kubectl get namespaces${RESET}\n"
  printf "\n"
  read -rp "Press Enter to continue..."
}

### MAIN MENU ###
main_menu() {
  while true; do
    printf "\n${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"
    printf "${BOLD}${CYAN}   Kubernetes Access Sharing Tool${RESET}\n"
    printf "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"
    printf "  Context: ${BOLD}%s${RESET}\n" "$CONTEXT"

    select_one "What would you like to do?" "List users" "Create user" "Edit user" "Delete user" "Change context" "Exit"

    case "$SELECTED_INDEX" in
      0) list_users ;;
      1) create_user ;;
      2) edit_user ;;
      3) delete_user ;;
      4) choose_context ;;
      5)
        printf "\n${GREEN}Goodbye!${RESET}\n\n"
        exit 0
        ;;
    esac
  done
}

### START ###
printf "\n${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"
printf "${BOLD}${CYAN}   Kubernetes Access Sharing Tool${RESET}\n"
printf "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}\n"

choose_context
main_menu
